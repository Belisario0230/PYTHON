# -*- coding: utf-8 -*-
"""Tema16.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1u1Hmt5QcoWMHMQC6HbAEHf1axhNqtNy6

# Módulos de `Python`: `numpy`

## `numpy`

`numpy` es un módulo para trabajar con arrays, que son un tipo de lista, lo que mucho más rápidos de procesar.

El objeto array de `numpy` recibe el nombre de `ndarray`. Este tipo de dato es muy usado en el mundo de la ciencia de datos, donde la velocidad y los recursos son de gran importancia.
"""

import numpy as np

"""Podemos comprobar la versión de `numpy` con la siguiente línea de código"""

print(np.__version__)

"""#### Creando arrays

Para crear un `ndarray` usamos el método `.array()`.

Lo podemos hacer a partir de una lista:
"""

a = np.array([1, 2, 3, 4, 5])
print(a)

print(type(a))

"""O bien, a partir de una tupla:"""

b = np.array((1, 2, 3, 4, 5, 6, 7))
print(b)

print(type(b))

"""### Dimensiones de un array

La dimensión de una array viene dada por el nivel de profundidad de éste.

Para saber la dimensión de un array, podemos usar la propiedad `.ndim`

**¡Cuidado!**. En las versiones actuales de `Python`, si creamos un array $n$-dimensional, entonces todos los arrays de dimensión fija $m < n$, deben contener el mismo número de elementos. Es decir, si creamos un array de 4 dimensiones, todos los arrays de 3 dimensiones deben tener el mismo número de elementos; por su parte, todos los arrays de 2 dimensiones, deben tener el mismo número de elementos; y lo mismo para los arrays 1-dimensionales. Esto se debe a que en caso contrario, el atributo `.shape` que veremos a continuación no tendría sentido.

#### Arrays 0-dimensionales

Son los arrays constantes:
"""

d0 = np.array(77)
d0.ndim

"""#### Arrays 1-dimensionales

Son los arrays con un solo nivel de profundidad
"""

d1 = np.array([-1, 0, 1])
d1.ndim

"""#### Arrays 2-dimensionales

Son los arrays que tienen por elementos arrays unidimensionales:
"""

d2 = np.array([[-3, -2], [-1, 0]])
d2.ndim

"""#### Arrays 3-dimensionales

Son los arrays que tinenen por elementos arrays bidimensionales:
"""

d3 = np.array([[[1, 2, 3, 4], [4, 3, 2, 1]], [[1, 0, 1, 0], [-1, 1, -1, 1]]])
d3.ndim

"""#### Arrays multidimensionales

Un array puede tener cualquier número finito de dimensiones.

A la hora de crear un `ndarray`, podemos indicar como parámetro el número de dimensiones que queramos que tenga dicho array con el argumento `ndmin`
"""

a = np.array([-2, -1, 0, 1, 2], ndmin = 7)
print("El array a tiene {} dimensiones".format(a.ndim))
print(a)

"""### `Shape` de un array

**Shape.** Es el número de elementos de cada dimensión.

Lo calculamos con el atributo `.shape`
"""

# Hay 3 elementos en el array 1-dimensional
d1 = np.array([-1, 0, 1])
d1.shape

# Hay 2 elementos en el array 2D y 2 elementos en los arrays 1D
d2 = np.array([[-3, -2], [-1, 0]])
d2.shape

# Hay 2 elementos en el array 3D, 2 elementos en cada array 2D y 4 elementos en cada array 1D
d3 = np.array([[[1, 2, 3, 4], [4, 3, 2, 1]], [[1, 0, 1, 0], [-1, 1, -1, 1]]])
d3.shape

"""La tupla resultante del atributo `.shape` se interpreta del siguiente modo:
* Cada elemento de la tupla nos indica el número de elementos que hay en cada dimensión.
* El primer índice se corresponde con la mayor dimensión, correspondiente al valor obtenido con `ndim`.
* El último índice se corresponde con la menor dimensión (dimensión 1).

Aquí es donde podemo observar la razón por la cuál todos los arrays de misma dimensión $m$ pertenecientes a un array $n$-dimensional, debe tener el mismo número de elementos.

Por ejemplo, dado un array 4D, todos los arrays 2D pertenecientes a este deben tener el mismo número de elementos, que será el que nos devuelva la tupla resultante de aplicar `.shape` en el índice correspondiente, que en este caso sería el índice 2 (tercer y penúltimo elemento de la tupla).

### Reshape de un array

**Reshape.** Cambiar la `shape` de un array

Mediante el proceso de reshape, podemos añadir o eliminar dimensiones, o bien cambiar el número de elementos de cada dimensión.

---
#### Ejemplo 1

Partiremos de un array 1D con 8 elementos y lo transformaremos en un array 2D con 2 arrays 1D, cada uno de ellos con 4 elementos.
"""

d1 = np.array([1, 2, 3, 4, 5, 6, 7, 8])
print("d1 =", d1)
print("Dimensión:", d1.ndim)
print("Shape:", d1.shape)

"""Nuestro array 1D `d1` consta de 8 elementos."""

d2 = d1.reshape(2, 4)
print("d2 =", d2)
print("Dimensión:", d2.ndim)
print("Shape:", d2.shape)

"""Nuestro nuevo array 2D `d2` consta de 2 arrays de dimensión 1, con 4 elementos cada uno. De modo que en total, seguimos teniendo los 8 elementos originales, pero con diferente `shape`.

**¡Cuidado!** A la hora de llevar a cabo un reshape, el producto de los elementos de la tupla resultante de aplicar `.shape` debe coincidir con el número total de elementos que tiene el array orignial.

En este caso, partíamos de 8 elementos en 1 dimensión y hemos acabado en $2\cdot 4 = 8$ elementos distribuidos en 2 dimensiones.

---

---
#### Ejemplo 2

En este caso, partiremos de un array 1D y lo transformaremos en un array 3D
"""

d1 = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])
print("d1 =", d1)
print("Dimensión:", d1.ndim)
print("Shape:", d1.shape)

"""Nuestro array 1D consta de 16 elementos."""

d3 = d1.reshape(2, 4, 2)
print("d3 =", d3)
print("Dimensión:", d3.ndim)
print("Shape:", d3.shape)

"""Nuestro array 3D consta de 2 arrays bidimensionales, cada uno con 4 arrays 1D, cada cual contiene 2 elementos.

En total, hay $2\cdot 4\cdot 2 = 16$ elementos, tal y como teníamos originalmente.

---

#### Ejemplo 3

En este caso, vamos a transformar un array 2D a un array 5D.
"""

d2 = np.array([[-10, -9, -8, -7], [-6, -5, -4, -3], [-2, -1, 1, 2], [3, 4, 5, 6], [7, 8, 9, 10]])
print("d2 =", d2)
print("Dimensión:", d2.ndim)
print("Shape:", d2.shape)

"""Partimos de un array 2D, que tiene 5 arrays 1D, cada uno con 4 elementos. En total hay 20 elementos."""

d5 = d2.reshape(2, 1, 2, 1, 5)
print("d5 =", d5)
print("Dimensión:", d5.ndim)
print("Shape:", d5.shape)

"""Hemos transformado nuestro array original 2D en un array 5D que consta de 2 arrays 4D, cada uno de los cuales contiene un array 3D, que tiene 2 arrays 2D con 1 array 1D en su interior que consta de 5 elementos. En total, $2\cdot 1\cdot 2\cdot 1\cdot 5 = 20$

---

**Observación.** El resultado de un `.reshape()` es una `view` del array original.
"""

print("El array transformado a partir del array d2 del Ejemplo 3 es una view,\npues al aplicar .base se nos devuelve el array 2D original:\n", d5.base)

"""#### Dimensión desconocida

Al hacer un reshape no siempre hay que especificar el número exacto de una de las dimensiones como parámetro del método `.reshape()`.

Si desconocemos una dimensión, basta indicar -1 en el lugar adecuado y `numpy` la calculará por nosotros.

Tomando el array 2D del Ejemplo 3,
"""

d2 = np.array([[-10, -9, -8, -7], [-6, -5, -4, -3], [-2, -1, 1, 2], [3, 4, 5, 6], [7, 8, 9, 10]])

"""supongamos que no sabemos la última dimensión a la hora de transformarlo al array 5D. En ese caso, introducimos -1 como parámetro."""

d5 = d2.reshape(2, 1, 2, 1, -1)
print("d5 =", d5)
print("Dimensión:", d5.ndim)
print("Shape:", d5.shape)

"""Observamos que `numpy` ha calculado dicha dimensión por nosotros, que coincide con el resultado indicado en el Ejemplo 3.

**¡Cuidado!** Solamente podemos pasar -1 por parámetro al método `.reshape()` para una sola dimensión.

**Observación.** El uso del -1 nos puede ser muy útil cuando queramos transformar cualquier array multidimensional a un array unidimensional.

Por ejemplo, partiendo del array 5D del Ejemplo 3, lo podemos trasformar a array undimensional del siguiente modo:
"""

d1 = d5.reshape(-1)
print("d1 =", d1)
print("Dimensión:", d1.ndim)
print("Shape:", d1.shape)

"""### Elementos de un array

#### Caso unidimensional

Podemos acceder a los elementos de un array con la sintaxis `[]`.

**Observación.** Recordad que en `Python` los índices empezaban en 0
"""

a = np.array([2, 3, 4, 5, 6])
print(a)

print("Primer elemento = ", a[0])
print("Segundo elemento = ", a[1])
print("Último elemento = ", a[-1])

"""#### Caso multidimensional

A la hora de acceder a elementos de un array multidimensional, tendremos que empezar indicando el índice del elemento en el nivel menos profundo y acabar indicando el índice del elemento en en nivel más profundo, todos entre `[]` separados por comas.

En el caso de un array bidimiensional, como el que se muestra a continuación,
"""

a = np.array([[-10, -9], [7, 8]])
a.ndim

"""Para acceder al elemento -9, primero habrá que indicar el índice 0, pues el array unidimensional al que pertenece se encuentra en el índice 0 del nivel menos profundo. A continuación, indicaremos el índice 1, pues esa es la posición que ocupa el elemento de nuestro interés dentro del array unidimensional, que se trata del nivel más profundo en este caso:"""

a[0, 1]

"""En el caso de un array tridimensional, como el que se muestra a continuación,"""

a = np.array([[[1, 2, 3], [-3, -2, -1]], [[4, 5, 6], [7, 8, 9]]])
a.ndim

"""Para acceder al elemento 7, primero habrá que indicar el índice 1, pues el array 2-dimensional al que pertenece se encuentra en la posición 1 del nivel menos profundo. Entramos en el siguiente nivel, el array 2-dimensional. Ahora, la posición que hay que indicar es la 1, pues el array 1-dimensional ocupa dicho índice dentro del array 2-dimensional. Finalmente, llegamos al nivel más profundo, el array 1-dimensional, y ahora hay que indicar el índice 0, pues esa es la posición que ocupa el elemento de nuestro interés dentro del array unidimensional."""

a[1, 1, 0]

"""Dado un array multidimensional, si lo que queremos es que se nos devuelva un array de dimensión menor, entonces solamnente tenemos que indicar sus índices tal cuál hacíamos para obtener un elemento.

Dado el array `a` tridimensional anterior, si queremos acceder al array unidimensional `[-3, -2, -1]`, entonces indicaremos entre `[]` los índices 0 y, a continuación, 1. Pues dicho array se encuentra en el primer array bidimensional y dentro de éste, ocupa la segunda posición, es decir, el índice 1:
"""

a[0, 1]

"""#### Índices negativos

Al igual que para el caso de las listas, los elementos de los `ndarrays` también pueden ser accedidos mediante índices negativos.

El índice `-1` hace referencia al último elemento; el `-2`, al penúltimo; el `-3` al antepenúltimo; y así sucesivamente.
"""

a[-1]

"""### Slicing

En `Python`, **slicing** hace referencia a tomar elementos desde un índice dado hasta otro proporcionado.

Ya conocemos la sintaxis:

* `[inicio:fin]` donde iremos desde el índice `inicio` hasta el índice `fin`-1, y lo haremos de 1 en 1
* `[inicio:fin:paso]` donde iremos desde el índice `inicio` hasta el índice `fin`-1, y lo haremos de `paso` en `paso`

#### Caso unidimensional
"""

# Array unidimensional
a1 = np.array([9, 8, 7, 6, 5, 4, 3])
a1

# Del segundo elemento al cuarto de 1 en 1
a1[1:4]

# Del primer elemento al sexto de 1 en 1
a1[:6]

# Del tercer elemento al último de 1 en 1
a1[2:]

# Del segundo elemento al sexto de 2 en 2
a1[1:6:2]

# Del primer elemento al quinto de 2 en 2
a1[:5:2]

# Del segundo elemento al último de 3 en 3
a1[1::3]

# Del primer elemento al último de 4 en 4
a1[::4]

"""#### Caso multidimensional

"""

# Array 4-dimensional
a4 = np.array([[[[-211, -210], [-29, -28], [-27, -26]], [[-25, -24], [-23, -22], [-21, -20]]],
               [[[-111, -110], [-19, -18], [-17, -16]], [[-15, -14], [-13, -12], [-11, -10]]],
               [[[111, 110], [19, 18], [17, 16]], [[15, 14], [13, 12], [11, 10]]],
               [[[211, 210], [29, 28], [27, 26]], [[25, 24], [23, 22], [21, 20]]]])
a4.ndim

a4.shape

"""El array 4-dimensional `a4` consta de 4 arrays tridimensionales, cada uno de ellos con 2 arrays bidimensionales que contienen cada uno 3 arrays unidimensionales."""

# Mostramos del segundo al tercer array 3D
a4[1:3]

# Del segundo array 2D del primer array 3D, mostramos los dos primeros arrays 1D
a4[0, 1, :2]

# Del segundo al último array 3D, mostramos el segundo array 1D del primer array 2D
a4[1:, 0, 1]

"""**Observación.** Al igual que para acceder a elementos, los índices negativos también funcionan en el slicing de arrays (Negative Slicing)"""

# De los dos últimos arrays 3D, mostramos el último elemento de, del último array 1D de cada array 2D
a4[-2:, :, -1, -1]

"""### Filtrando arrays

Filtrar un array implica la selección de elementos de un array existente que satisfagan una condición y crear un nuevo array con dichos elementos.

La sintaxis es muy similar al slicing, pero en vez de eso, entre corchetes indicamos una condición booleana. Los elementos que satisfagan la condición serán los que permanezcan, mientras que el resto serán omitidos.

Visto de otro modo, la condición crea un array booleano. Aquellas posiciones ocupadas por un `True` serán las contenidas en el array filtrado, mientras que las que estén ocupadas por `False` (porque no satisfacen la condición), serán descartadas.
"""

a = np.array([4, 3, 2, 3, 4])
b = a[a == 4]
print(b)

a == 4

c = a[a % 2 == 0]
print(c)

d = a[a <= 2]
print(d)

d5[d5 % 2 == 0]

"""### Tipos de datos en `numpy`

Por defecto, `Python` tiene los siguientes tipos de dato:

* `int`: integer
* `float`: float
* `complex`: complex float
* `bool`: boolean
* `str`: string

En `numpy` encontramos tipos de datos adicicionales

* `i`: integer
* `u`: unsigned integer
* `f`: float
* `c`: complex float
* `b`: boolean
* `m`: timedelta
* `M`: datetime
* `O`: object
* `S`: string
* `U`: unicode string
* `V`: void

Para comprobar el tipo de dato de un array, usamos el método `.dtype`
"""

a = np.array([1, 2, 3])
print(a)
a.dtype

"""**Observación.** Como podéis ver, no solo se muestra el tipo de dato, sino también el tamaño"""

a = np.array([1.5, 2.4, 3.7])
print(a)
a.dtype

a = np.array([1j, 2 + 3j, 3 - 7j])
print(a)
a.dtype

a = np.array(["araña", "barco", "colonia"])
print(a)
a.dtype

a = np.array(["a", "b", "c"])
print(a)
a.dtype

"""Al usar el método `.array()`, existe un parámetro `dtype` que nos permite definir el tipo de dato que queremos que tengan los elementos de dicho ndarray"""

a = np.array([1, 2, 3, 4, 5], dtype = "S")
print(a)
a.dtype

"""**Observación.** Para el caso de los tipos de dato `i`, `u`, `f`, `S` y `U`, con el parámetro `dtype` también podemos definir el tamaño"""

a = np.array([1, 2, 3, 4, 5], dtype = "i1")
print(a)
a.dtype

a = np.array([1, 2, 3, 4, 5], dtype = "i2")
print(a)
a.dtype

a = np.array([1, 2, 3, 4, 5], dtype = "f8")
print(a)
a.dtype

a = np.array([1, 2, 3, 4, 5], dtype = "c16")
print(a)
a.dtype

a = np.array([1, 2, 3, 4, 5], dtype = "S2")
print(a)
a.dtype

"""Si queremos cambiar el tipo de dato de un array existente, usamos el método `.astype()`"""

a = np.array([1, 2, 3, 4, 5], dtype = "f16")
print("El array a es de tipo", a.dtype)
b = a.astype("i")
print("El array b es de tipo", b.dtype)

a = np.array([1, 2, 3, 4, 5], dtype = "f16")
print("El array a es de tipo", a.dtype)
b = a.astype(int)
print("El array b es de tipo", b.dtype)

a = np.array([1, 0, 3, 0, 5, -10])
print(a)
print("El array a es de tipo", a.dtype)
b = a.astype(bool)
print(b)
print("El array b es de tipo", b.dtype)

"""### Copias y Views de arrays

**Copia.** Una copia de un array crea un nuevo array exactamente igual al original.

La copia no es afectada pos los cambios aplicados en el array original.
"""

x = np.array(["a", "b", "c"])
print(x)
x_copy = x.copy()
print(x_copy)

"""**View.** Una view de un array es una referencial al array original.

Los cambios aplicados al array original afectan también a la view, y viceversa.
"""

y = np.array([1, 2, 3])
print("y =", y)
y_view = y.view()
print("y_view =", y_view)

"""Si modificamos el original, veremos los cambios también aplicados en la view"""

y[1] = 0
print("y =", y)
print("y_view =", y_view)

"""Si modificamos la view, veremos los cambios también aplicados en el array original"""

y_view[0] = -3
print("y =", y)
print("y_view =", y_view)

"""Para asegurarnos de si hemos hecho una copia o una view, podemos usar el método `.base`, que nos devolverá `None` si se trata de una copia y nos devolverá el array original si se trata de una view."""

z = np.array([1j, 0, -1j])
z_copy = z.copy()
z_view = z.view()

print("z_copy nos devuelve", z_copy.base, "porque es una copia")
print("z_view nos devuelve", z_view.base, "porque es una view")

"""### Arrays y bucles

Podemos iterar un array tal cual lo hacíamos con listas:

#### Array 1D
"""

d1 = np.array(["a", "b", "c"])

for i in d1:
  print(i)

"""#### Array 2D"""

d2 = np.array([["a", "b", "c"], [1, 2, 3]])

# Imprimimos los elementos del array 2D
for d1 in d2:
  print(d1)

# Imprimimos los elementos de los arrays 1D
for d1 in d2:
  for i in d1:
    print(i)

"""#### Array 3D"""

d3 = np.array([[["a", "b", "c", "d"], ["e", "f", "g", "h"]], [[1, 2, 3, 4], [5, 6, 7, 8]]])
d3.dtype

# Imprimimos los elementos del array 3D
for d2 in d3:
  print(d2)

# Imprimimos los elementos de los arrays 2D
for d2 in d3:
  for d1 in d2:
    print(d1)

# Imprimimos los elementos de los arrays 1D
for d2 in d3:
  for d1 in d2:
    for i in d1:
      print(i)

"""Como vemos, cada vez que aumentamos la dimensión del array, hay que anidar bucles `for` para imprimir cada uno de los elementos de los arrays 1D.

Como alternativa podríamos hacer un reshape del array multidimensional a un array unidimensional, pero dado un array con dimensión suficientemente grande, este proceso sería computacionalmente muy costoso:
"""

for i in d3.reshape(-1):
  print(i)

"""#### El método `.nditer()`

Para evitarnos tantas líneas de código y tanto coste computacional, tenemos el método `.nditer()`, que nos crea un iterable el cual nos permite imprimir todos los elementos de los arrays 1D, tal cuál hemos estado obteniendo hasta ahora:
"""

for i in np.nditer(d3):
  print(i)

"""El método `.nditer()` también nos permite cambiar el tipo de dato de los elementos de un array durante la iteración mediante el parámetro `op_dtypes`.

`numpy` no ambia el tipo de dato de los elementos de un array en el sitio, de modo qu enecesita algún otro espacio para llevar a cabo esta acción. Este espacio extra es llamado **buffer** y se lo proporcionamos al método `.nditer()` con el argumento `flags = ["buffered"]`
"""

d2 = np.array([[1, 2], [3, 4], [5, 6]])
for i in np.nditer(d2, flags = ["buffered"], op_dtypes = ["S"]):
  print(i)

"""El método `.nditer()` también nos permite iterar con distinto paso (de 1 en 1, de 2 en 2, ...)"""

d2 = np.array([[1, 2], [3, 4], [5, 6]])
for i in np.nditer(d2[:, ::2]):
  print(i)

"""#### El método `.ndenumerate()`

A veces necesitamos el índice correspondiente al elemento durante la iteración. El método `.ndenumerate()` nos proporciona dicha información.


"""

d1 = np.array(["a", "b", "c"])

for idx, i in np.ndenumerate(d1):
  print("Índice:", idx,"Elemento:", i)

d2 = np.array([[1, 2], [3, 4], [5, 6]])

for idx, i in np.ndenumerate(d2):
  print("Índice:", idx,"Elemento:", i)

d3 = np.array([[["a", "b", "c", "d"], ["e", "f", "g", "h"]], [[1, 2, 3, 4], [5, 6, 7, 8]]])

for idx, i in np.ndenumerate(d3):
  print("Índice:", idx,"Elemento:", i)

"""### Concatenación de arrays

Para concatenar arrays, es decir, juntar dos o más arrays en un único array, usamos el método `.concatenate()`
"""

# Conatenamos arrays 1D
a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])
a = np.concatenate((a1, a2))
print(a)

# Concatenamos arrays 2D
b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])

# Con axis = 0
b = np.concatenate((b1, b2), axis = 0)
print("axis = 0 nos devuelve\n", b)

# Con axis = 1
b = np.concatenate((b1, b2), axis = 1)
print("\naxis = 1 nos devuelve\n", b)

"""**Observación.** En este caso, nos funcionan ambas configuraciones del valor `axis` pues los dos arrays 2D, `b1` y `b2` tienen tanto el mismo número de arrays 1D como el mismo número de elementos dentro de cada array 1D.

Si indicamos `axis = 0`, se nos combinan ambos arrays 2D en un solo array 2D. En este caso es necesario que todos los arrays 1D tengan el mismo número de elementos.

Sin embargo, si seleccionamos `axis = 1`, entonces obtenemos como resultado un array 2D con cada uno de los arrays 1D concatenados. En este caso necesitamos que en ambos arrays 2D haya el mismo número de arrays 1D.
"""

# Concatenamos arrays 3D
c1 = np.array([[[-10, -9], [-8, -7], [-6, -5]], [[-4, -3], [-2, -1], [0, 0]]])
c2 = np.array([[[0, 0], [1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]]])

# Con axis = 0
c = np.concatenate((c1, c2), axis = 0)
print("axis = 0 nos devuelve\n", c)

# Con axis = 1
c = np.concatenate((c1, c2), axis = 1)
print("\naxis = 1 nos devuelve\n", c)

# Con axis = 2
c = np.concatenate((c1, c2), axis = 2)
print("\naxis = 2 nos devuelve\n", c)

"""**Observación.** En este caso, nos vuelven a funcionar todas las configuraciones del valor `axis` pues los dos arrays 3D, `c1` y `c2` tienen tanto el mismo número de arrays 2D, como el mismo número de arrays 1D en cada array 2D, como el mismo número de elementos dentro de cada array 1D.

Si indicamos `axis = 0`, se nos combinan ambos arrays 3D en un solo array 3D. Por su parte, si seleccionamos `axis = 1`, entonces obtenemos como resultado un array 3D con cada uno de los arrays 2D concatenados. Por último, si indicamos `axis = 2`, obtendremos un array 3D donde los arrays 1D han sido concatenados.

**Observación.** Si queremos concatenar arrays $n$-dimensionales, tendremos $n-1$ opciones para el parámetro `axis`.

#### Concatenación de arrays usando `.stack()`

Llevar a cabo un stack es lo mismo que concatenar, solo que el stack se hace sobre un eje nuevo.

Por ejemplo, podemos concatenar dos arrays unidimensionales sobre un segundo eje, lo que resultaría en poner un array sobre el otro: realizar un stack.
"""

a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])

# Hacemos stack de arrays 1D con axis = 0
a = np.stack((a1, a2), axis = 0)
print(a)

# Hacemos stack de arrays 1D con axis = 1
a = np.stack((a1, a2), axis = 1)
print(a)

"""**Observación.** Al hacer stack de los arrays 1D, habiendo seleccionado `axis = 0`, obtenemos como resultado un array 2D con los dos arrays 1D originales. Sin embargo, si elegimos `axis = 1`, obtenemos nuevamente un array 2D, pero éste consta de 3 elementos 1D (en este ejemplo en concreto), cada cual con 2 elementos (el primero se corresponde con un elemento del array original `a1`, mientras que el segundo, con un elemento del array `a2`)"""

b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])

# Hacemos stack de arrays 2D con axis = 0
b = np.stack((b1, b2), axis = 0)
print(b)

# Hacemos stack de arrays 2D con axis = 1
b = np.stack((b1, b2), axis = 1)
print(b)

# Hacemos stack de arrays 2D con axis = 2
b = np.stack((b1, b2), axis = 2)
print(b)

"""**Observación.** Al hacer stack de los arrays 2D, habiendo seleccionado `axis = 0`, obtenemos como resultado un array 3D con los dos arrays 2D originales. Por su parte, si elegimos `axis = 1`, obtenemos nuevamente un array 3D, pero éste consta de 3 elementos 2D (en este ejemplo en concreto), cada cual con 2 elementos 1D (el primero se corresponde con un elemento del array original `b1`, mientras que el segundo, con un elemento del array `b2`). Por último, si consideramos `axis = 2`, obtenemos también un array 3D, que consta de 3 elementos 2D (en este ejemplo en concreto), cada uno con 2 elementos 1D que han sido concatenados del siguiente modo: el primer elemento del array 1D se corresponde con un elemento original del array `b1`, mientras que el segundo y último elemento del array 1D procede del array `b2`.

**Observación.** Si queremos hacer stack de arrays $n$-dimensionales, tendremos $n$ opciones para el parámetro `axis` y siempre obtendremos como resultado un array de dimensión $n+1$ que ha sido combinado según el `axis` seleccionado.

#### Concatenando por filas

`numpy` proporciona la función helper `hstack()` que lleva a cabo una concatenación por filas:
"""

# Caso 1D (se corresponde con el resultado de .concatenate())
a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])
a = np.hstack((a1, a2))
print(a)

# Caso 2D (se corresponde con el resultado de .concatenate() con axis = 1)
b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])
b = np.hstack((b1, b2))
print(b)

# Caso 3D (se corresponde con el resultado de .concatenate() con axis = 1)
c1 = np.array([[[-10, -9], [-8, -7], [-6, -5]], [[-4, -3], [-2, -1], [0, 0]]])
c2 = np.array([[[0, 0], [1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]]])
c = np.hstack((c1, c2))
print(c)

"""#### Concatenando por columnas

`numpy` proporciona la función helper `vstack()` que lleva a cabo una concatenación por columnas:
"""

# Caso 1D (se corresponde con el resultado de .stack() con axis = 0)
a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])
a = np.vstack((a1, a2))
print(a)

# Caso 2D (se corresponde con el resultado de .concatenate() con axis = 0)
b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])
b = np.vstack((b1, b2))
print(b)

# Caso 3D (se corresponde con el resultado de .concatenate() con axis = 0)
c1 = np.array([[[-10, -9], [-8, -7], [-6, -5]], [[-4, -3], [-2, -1], [0, 0]]])
c2 = np.array([[[0, 0], [1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]]])
c = np.vstack((c1, c2))
print(c)

"""#### Concatenando por profundidad

`numpy` proporciona la función helper `dstack()` que lleva a cabo una concatenación por profundidad:
"""

# Caso 1D (se corresponde con el resultado de .stack() con axis = 1)
a1 = np.array([-3, -2, -1])
a2 = np.array([1, 2, 3])
a = np.dstack((a1, a2))
print(a)

# Caso 2D (se corresponde con el resultado de .stack() con axis = 2)
b1 = np.array([[-6, -5], [-4, -3], [-2, -1]])
b2 = np.array([[1, 2], [3, 4], [5, 6]])
b = np.dstack((b1, b2))
print(b)

# Caso 3D (se corresponde con el resultado de .concatenate() con axis = 2)
c1 = np.array([[[-10, -9], [-8, -7], [-6, -5]], [[-4, -3], [-2, -1], [0, 0]]])
c2 = np.array([[[0, 0], [1, 2], [3, 4]], [[5, 6], [7, 8], [9, 10]]])
c = np.dstack((c1, c2))
print(c)

"""### División de arrays

El proceso inverso a la concatenación es la división de arrays. La división de arrays consiste en romper un array en múltiples arrays.

Para dividir arrays usamos el método `.array_split()`

#### Dividiendo arrays 1D
"""

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = np.array_split(x, 4)
print("Del array original x =", x)
print("Dividiéndolo en 4 obtenemos:", y)

"""Como resultado, obtenemos una lista con el número de arrays 1D que hemos indicado por parámetro.

**Observación.** El array original lo podemos dividir en 2, 3,... hasta en tantos arrays como elementos contenga. Es decir, dado por ejemplo un array 1D con 8 elementos, podemos dividirlo en 2, 3, 4, ..., 8 arrays:
"""

for i in range(2, x.shape[0] + 1):
  print("Dividimos en {} arrays: {}".format(i, np.array_split(x, i)))

"""**Observación.** Si el número de arrays en que queremos dividir el array original, $m$, es divisor del número de elementos que tiene el array original, $n$, entonces todos los arrays resultantes tendrán el mismo número de elementos, $q$, donde $q$ es el cociente de la división entera de $n$ entre $m$.

En cambio, si el número introducido por parámetro, $m$, no es divisor del número total de elementos del array original, $n$, entonces los $r$ primeros arrays resultantes, siendo $r$ el resto de la división entera de $n$ entre $m$, tendrán cada uno de ellos $q + 1$ elementos, mientras que el resto de arrays, los $m-r$ restantes, tendrán $q$ elementos. De modo que

$$n = r\cdot (q + 1) + (m - r)\cdot q = qr + r + mq - qr = mq + r $$

---
#### Ejemplo 4

Consideremos un array 1D con 20 elementos. Entonces,
"""

a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10,
              11, 12, 13, 14, 15, 16, 17, 18, 19, 20])

n = a.shape[0]
for m in range(2, n + 1):
  print("\nDividimos el array original en {} arrays".format(m))
  q = n//m
  r = n % m
  print("n = {}, m = {}, q = {}, r = {}".format(n, m, q, r))

  if r == 0:
    print("Los {} arrays resultantes tienen el mismo número de elementos: {}".format(m, q))

  else:
    print("Los primeros {} arrays tienen {} elementos. El resto de los arrays tienen {} elementos".format(r, q + 1, q))

  for i in np.array_split(a, m):
    print(i)

"""---

#### El método `.split()`

A la hora de dividir arrays tenemos también el método `.split()`, pero falla en caso de que el número de arrays en que queramos dividir el array original no sea divisor del número de elementos del array.
"""

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = np.split(x, 4)
print("Del array original x =", x)
print("Dividiéndolo en 4 obtenemos:", y)

"""Al cumplirse que el número de arrays en que queremos dividir el array original es divisor del número de elementos del array, obtenemos el mismo resultado que al usar el método `.array_split()`.

El siguiente caso, donde queremos dividir los 8 elementos en 3 arrays, nos dará error pues la división no es exacta:
"""

x = np.array([1, 2, 3, 4, 5, 6, 7, 8])
y = np.split(x, 3)

"""#### Dividiendo arrays 2D

Podemos también dividir arrays 2D en múltiples arrays 2D:
"""

x = np.array([[-1, 0, 1], [-2, 0, 2], [-3, 0, 3],
              [-4, 0, 4], [-5, 0, 5], [-6, 0, 6]])
y = np.array_split(x, 3)
print("Del array original x =\n", x)
print("Dividiéndolo en 3 obtenemos:")
for i in y:
  print(i)

"""Como resultado, obtenemos una lista con el número de arrays 2D que hemos indicado por parámetro.

De nuevo, el array 2D original lo podemos dividir en 2, 3,... hasta en tantos arrays como elementos 1D contenga. Es decir, dado por ejemplo un array 2D con 6 arrays 1D, podemos dividirlo en 2, 3, 4, ..., 6 arrays 2D:
"""

for i in range(2, x.shape[0] + 1):
  print("\nDividimos el array original en {} arrays:".format(i))
  for j in np.array_split(x, i):
    print(j)

"""**Observación.** En el caso 2D, vuelve a satisfacerse que si el número de arrays en que queremos dividir el array 2D original, $m$, es divisor del número de elementos 1D que tiene el array original 2D, $n$, entonces todos los arrays 2D resultantes tendrán el mismo número de arrays 1D, $q$, donde $q$ es el cociente de la división entera de $n$ entre $m$.

En cambio, si el número introducido por parámetro, $m$, no es divisor del número total de arrays 1D que contiene el array original, $n$, entonces los $r$ primeros arrays 2D resultantes, siendo $r$ el resto de la división entera de $n$ entre $m$, tendrán cada uno de ellos $q + 1$ elementos, mientras que el resto de arrays 2D, los $m-r$ restantes, tendrán $q$ elementos. De modo que

$$n = r\cdot (q + 1) + (m - r)\cdot q = qr + r + mq - qr = mq + r $$

En el caso de dividir arrays multidimensionales, volvemos a tener la opción de configurar el parámetro `axis`.
"""

x = np.array([[-1, 0, 1], [-2, 0, 2], [-3, 0, 3],
              [-4, 0, 4], [-5, 0, 5], [-6, 0, 6]])
print("Del array original x =\n", x)
print("Dividiéndolo en 3 con axis = 0 obtenemos:")
y = np.array_split(x, 3, axis = 0)
for i in y:
  print(i)

print("\nDividiéndolo en 3 con axis = 1 obtenemos:")
y = np.array_split(x, 3, axis = 1)
for i in y:
  print(i)

"""En el caso de `axis = 0`, obtenemos como resultado una lista de arrays 2D donde se han repartido los arrays 1D en el número de arrays 2D indicado por parámetro a la función y del modo que hemos explicado anteriormente.

En el caso de `axis = 1`, obtenemos como resultado una lista de arrays 2D, tantos como se ha indicado por parámetro, donde se han repartido los elementos de cada array 1D.

**Observación.** En el caso 2D, si configuramos `axis = 1`, si el número de arrays en que queremos dividir el array 2D original, $m$, es divisor del número de elementos contenidos en cada array 1D del array original 2D, $n$, entonces todos los arrays 2D resultantes tendrán tantos arrays 1D como tenían originalmente, los cuales tendrán todos el mismo número de elementos, $q$, donde $q$ es el cociente de la división entera de $n$ entre $m$.

En cambio, si el número introducido por parámetro, $m$, no es divisor del número total de elementos contenidos en cada array 1D del array original 2D, $n$, entonces todos los arrays 2D resultantes tendrán el mismo número de arrays 1D que el original, pero los arrays 1D de los $r$ primeros arrays 2D resultantes, siendo $r$ el resto de la división entera de $n$ entre $m$, tendrán cada uno de ellos $q + 1$ elementos, mientras que los arrays 1D para el resto de arrays 2D, los $m-r$ restantes, tendrán $q$ elementos cada uno de ellos. De modo que

$$n = r\cdot (q + 1) + (m - r)\cdot q = qr + r + mq - qr = mq + r $$

**Observación.** Para el caso de `axis = 1`, podremos dividir el array original en 2, 3, ..., hasta el número de elementos que contengan cada uno de los arrays 1D del array 2D original.

---
#### Ejemplo 5

Consideremos un array 2D con 4 arrays 1D, cada uno de los cuales contiene 5 elementos.
"""

a = np.array([[1, 2, 3, 4, 5],
              [6, 7, 8, 9, 10],
              [11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20]])

print("La shape del array 2D original es:", a.shape)

n = a.shape[-1] # Tomamos el número de elementos que contiene cada array 1D
for m in range(2, n + 1):
  print("\nDividimos el array original 2D en {} arrays con axis = 1".format(m))
  q = n//m
  r = n % m
  print("n = {}, m = {}, q = {}, r = {}".format(n, m, q, r))

  print("Los {} arrays resultantes contienen el mismo número de arrays 1D que el original".format(m), sep = " ")
  if r == 0:
    print("cada uno de ellos con el mismo número de elementos: {}".format(q))

  else:
    print("\nEn este caso, para los primeros {} arrays 2D, cada array 1D tiene {} elementos.".format(r, q + 1))
    print("para los arrays 2D restantes, cada array 1D tiene {} elementos".format(q))

  for i in np.array_split(a, m, axis = 1):
    print(i)

"""---

#### El método `.hsplit()`

`numpy` nos proporciona una función helper, el método `.hsplit()` que lleva a cabo el proceso inverso a `.hstack()`
"""

a = np.array([[1, 2, 3, 4, 5],
              [6, 7, 8, 9, 10],
              [11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20]])

for i in np.hsplit(a, 5):
  print(i)

"""El resultado de este método es equivalente al que obtendríamos si usáramos el método `.array_split()` con `axis = 1`. No obstante, este método dará error si el número de arrays en que queremos dividir el array original, $m$, no coincide con el número de elementos que contiene cada array 1D del array original 2D, $n$.

#### El método `.vsplit()`

`numpy` nos proporciona una función helper, el método `.vsplit()` que lleva a cabo el proceso inverso a `.vstack()`
"""

a = np.array([[1, 2, 3, 4, 5],
              [6, 7, 8, 9, 10],
              [11, 12, 13, 14, 15],
              [16, 17, 18, 19, 20]])

for i in np.vsplit(a, 2):
  print(i)

"""El resultado de este método es equivalente al que obtendríamos si usáramos el método `.array_split()` con `axis = 0`. No obstante, este método dará error si el número de arrays en que queremos dividir el array original, $m$, no coincide con el número de arrays 1D del array original 2D, $n$.

#### Dividiendo arrays multidimensionales

Para dividir arrays $d$-dimensionales, siendo $d > 2$, podemos usar el método `.array_split()` como hasta ahora.

A medida que $d$ sea mayor, tendremos más posibilidades para el parámetro `axis`. En concreto, tendremos $d$ posibles elecciones: `axis = 0`, `axis = 1`, ..., hasta `axis = d - 1`.

#### El método `.dsplit()`

Si tenemos arrays multidimensionales, cuya dimensión es mayor o igual a 3, entonces podremos usar el método `.dsplit()`, que se trata de una función helper, la inversa a `.dstack()` y se corresponde con el resultado de `.array_split()` con `axis = 2`.

Lo que hay que tener en cuenta que `.dsplit()` funcionará únicamente si el número de arrays $d$-dimensionales en que queremos dividir el array $d$-dimensional original, $m$, es divisor del número de elementos que contiene cada array $(d-2)$-dimensional del array original.

Si d = 3, entonces el número de arrays tridimensionales $m$ que indiquemos por parámetro deberá ser divisor del número de elementos que contiene cada array unidimensional ($d - 2 = 1$) del array tridimensional original.
"""

a = np.array([[[1, 2, 3, 4],
              [6, 7, 8, 9],
              [11, 12, 13, 14],
              [16, 17, 18, 19]],

              [[1, 2, 3, 4],
              [6, 7, 8, 9],
              [11, 12, 13, 14],
              [16, 17, 18, 19]]])

for i in np.dsplit(a, 2):
  print(i)

"""### Buscando elementos en un array

Podemos buscar elementos en concreto de un array con el método `.where()` que nos devolverá un array de índices en los cuales se encuentra el elemento que estamos buscando.

Por ejemplo, dado el siguiente array 1D `x`, busquemos en qué posiciones éste toma el valor 0.
"""

x = np.array([1, 0, -1, 0, 2, 0, -2, 0])
idx0 = np.where(x == 0)

print(idx0)

"""Como resultado hemos obtenido que en los índices 1, 3, 5 y 7 del array `x` se toma el valor 0.

**Observación.** Podemos poner cualquier tipo de condición a modo de argumento del método `.where()`.

Dado el siguiente array 1D `y`, busquemos en qué índices se toman valores pares.
"""

y = np.array([2, 3, 6, 7, 14, 15, 30, 31])
z = np.where(y % 2 == 0)

print(z)

y = np.array([[2, 3, 6, 7],
              [14, 15, 30, 31]])
z = np.where(y % 2 == 0)

print(z)

"""#### El método `.searchsorted()`

El método `.searchsorted()` lleva a cabo una búsqueda binaria en el array y devuelve los índices donde el valor indicado por parámetro sería colocado de modo que se mantuviese el orden de búsqueda:
"""

a = np.array([-10, -9, -8, -7])
b = np.searchsorted(a, -9.5)
c = np.searchsorted(a, -6.5)
print("El elemento -9.5 deberá ocupar el índice", b)
print("El elemento -6.5 deberá ocupar el índice", c)

"""**Observación.** En caso de no proporcionar un array ya ordenado, `numpy` lo ordena por defecto:

* Los números van en orden ascendente
* Las letras y strings en orden alfabético
"""

a = np.array([-10, -8, -9, -7])
b = np.searchsorted(a, -9.5)
c = np.searchsorted(a, -6.5)
print("El elemento -9.5 deberá ocupar el índice", b)
print("El elemento -6.5 deberá ocupar el índice", c)

"""Por defecto, se nos devuelve el primer índice (empezando por la izquierda) que podría ocupar el elemento que queremos introducir dentro del array. Para mostrar el último índice que podría ocupar dicho elemento, existe un parámetro llamado `side` y habrá que igualarlo a `"right"` para obtener dicho índice:"""

a = np.array([-10, -9, -8, -7])
b_left = np.searchsorted(a, -9, side = "left")
b_right = np.searchsorted(a, -9, side = "right")
c_left = np.searchsorted(a, -7, side = "left")
c_right = np.searchsorted(a, -7, side = "right")
print("El elemento -9 puede ocupar como pronto el índice", b_left)
print("El elemento -9  puede ocupar como tarde el índice", b_right)
print("El elemento -7 puede ocupar como pronto el índice", c_left)
print("El elemento -7 puede ocupar como tarde  el índice", c_right)

"""En vez de ir de elemento en elemento, podemos introducir por parámetro una lista de elementos a introducir en el array:"""

x = np.array([4, 8, 12, 16])
y = np.searchsorted(x, [3, 6, 9])
print(y)

"""Como resultado obtendremos un array con los índices en que se introducirían cada uno de los elementos de la lista dentro del array:

* El elemento 3 ocuparía el índice 0 dentro del array original `x`, quedando como resultado `[3, 4, 8, 12, 16]`
* El elemento 6 ocuparía el índice 1 dentro del array original `x` quedando como resultado `[4, 6, 8, 12, 16]`
* El elemento 9 ocuparía el índice 2 dentro del array original `x` quedando como resultado `[4, 8, 9, 12, 16]`

### Ordenando arrays

Ordenar arrays implica reordenar los elementos siguiendo una secuencia ordenada.

A su vez, una secuencia ordenada es cualquier sucesión que tiene un orden ciuos elementos siguen, como por ejemplo el orden alfabético o numérico, tanto ascendente como descendente.

Para ordenar los elementos de un array, disponemos del método `.sort()`
"""

x = np.array(["c", "m", "k", "z", "a"])
print(np.sort(x))

x = np.array(["caracol", "mariposa", "escarabajo", "perezoso", "armadillo"])
print(np.sort(x))

x = np.array([2, -2, 5, -5, 10, -10, 0])
print(np.sort(x))

x = np.array([2.5, -2.3, 5.1, -5.7, 10.9, -10.6, 0.4])
print(np.sort(x))

x = np.array([True, False, True, False])
print(np.sort(x))

"""A modo de resultado obtenemos una copia del array original, con los elementos ordenados por defecto de forma ascendente.

También podemos ordenar arrays multidimensionales:
"""

y = np.array([[2, 4, 3], [-4, -2, -3]])
print(np.sort(y))

"""Y podemos elegir sobre qué eje ordenarlos con el parámetro `axis`"""

y = np.array([[2, 4, 3], [-4, -2, -3]])
print(np.sort(y, axis = 0))
print(np.sort(y, axis = 1))

"""Por defecto, si no indicamos el parámetro `axis` se ordena siempre con respecto al último eje.

`axis = 0` ordena los elementos dentro de la mayor dimensión. En este caso, ordena los arrays 1D dentro del array 2D.

`axis = 1` ordena los elementos dentro de la segunda mayor dimensión. En este caso, ordena los elementos de los arrays 1D.

**Observación.** Dado un array $n$-dimensional, tendremos $n$ opciones para `axis`: 0 (dimensión mayor), 1 (segunda mayor dimensión), ..., $n-1$ (dimensión menor, equivalente a no indicar parámetro `axis` o igualar `axis = -1`).

### Elementos aleatorios en `numpy`

**Número aleatorio.** Un número aleatorio singifica que se trata de un número que no puede ser predicho lógicamente.

**¡Cuidado!** No hay que confundir número aleatorio con que se genere un número diferente cada vez que ejecutemos.

Como los ordenadores trabajan mediante algoritmos, un programa destinado a generar números aleatorios implica que los números no serán realmente aleatorios. Los números aleatorios generados mediante un algoritmo son conocidos como **números pseudoaleatorios**.

En este apartado trabajaremos con números pseudoaleatorios y veremos como generarlos.

#### El módulo `random`

`numpy` tiene el módulo `random` dedicado a trabajar con números aleatorios

Para generar números enteros aleatorios, usamos el método `.randint()`
"""

from numpy import random

# Generamos un número entero aleatorio del 1 al 20
n = random.randint(1, 20)
print(n)

# Generamos un número entero aleatorio del 0 al 10
m = random.randint(10)
print(m)

"""Para generar números reales aleatorios dentro del intervalo $[0, 1]$, usamos el método `.rand()`"""

# Generamos un número real aleatorio entre el 0 y el 1
x = random.rand()
print(x)

"""#### Arrays aleatorios

Podemos generar arrays aleatorios tanto con el método `.randint()` como con el método `.rand()`
"""

# Generamos un array 1D de 5 elementos enteros aleatorios
a = random.randint(100, size = 5)
print(a)

# Generamos un array 1D de 3 elementos reales aleatorios
b = random.rand(3)
print(b)

# Generamos un array 2D de 5 arrays 1D cada uno con 4 enteros aleatorios
c = random.randint(50, size = (5, 4))
print(c)

# Generamos un array 3D de 2 arrays 2D cada uno con 4 arrays 1D
#   cada uno con 3 reales aleatorios
d = random.rand(2, 4, 3)
print(d)

"""#### Elegir un elemento aleatorio de un array

Dado un array, podemos elegir aleatoriamente un elemento suyo con el método `.choice()`
"""

x = np.array([1, 2, 3, 4, 5, -5, -4, -3, -2, -1])
print(random.choice(x))

"""El método `.choice()` también consta del parámetro `size`, con lo cual podemos generar un array aleatorio con los elementos de un array dado:"""

print(random.choice(x, size = (3, 6)))

"""**¡Cuidado!** El método `.choice()` solamente toma como parámetro arrays unidimensionales

Existe otro parámetro del método `.choice()` que nos permite modificar las probabilidades de cada elemento. Éste es el parámetro `p`, al que le tendremos que proporcionar una lista de probabilidades (todos los elementos deben ser menores o iguales a 1 y la suma de todos ellos debe ser 1).

**Observación.** Por defecto, todos los elementos son equiprobables, es decir, tienen la misma probabilidad que es $\frac{1}{n}$, siendo $n$ el número de elementos del array.
"""

x = np.array([1, 2, 3, 4, 5, -5, -4, -3, -2, -1])
print(random.choice(x,
                    p = [0.2, 0.2, 0.05, 0.05, 0.05, 0.05, 0.1, 0.1, 0.05, 0.15],
                    size = (2, 6)))

"""En el chunk anterior se ha generado un array 2D con 2 arrays 1D cada uno con 6 elementos, donde las probabilidades para los elementos del array original son:

* Los elementos `1` y `2` tienen probabilidad 0.2 de salir
* El elemento `-1` tiene probabilidad 0.15
* Los elementos `-4` y `-3` tienen probabilidad 0.1 de salir
* Los elementos `3`, `4`, `5`, `6` y `-2` tienen probabilidad 0.05

Todas las probabilidades se encuentran en el intervalo $[0, 1]$ y si las sumamos dan 1.

#### Permutaciones aleatorias

**Permutación.** Una permutación de un array se refiere a la reordenación de sus elementos.

El módulo `random` de `numpy` nos proporciona dos métodos para crear permutaciones aleatorias de un array dado:

* `.shuffle()` modifica el array original
* `.permutation()` que crea una copia
"""

a = np.array([1, 2, 3, 4])
random.shuffle(a)

print("Array original permutado:", a)

a = np.array([1, 2, 3, 4])
b = random.permutation(a)

print("Array original permutado:", b)
print("Array original:", a)

"""### Funciones universales

Las funciones universales son aquellas que operan sobre el objeto ndarray

Podemos comprobar si un método se trata de una función universal con la función `type`. Cuando se trata de una función universal, obtenemos que es de tipo `np.ufunc`
"""

# Es una función universal
print(type(np.multiply))

type(np.multiply) == np.ufunc

# No es una función universal
print(type(np.concatenate))

type(np.concatenate) == np.ufunc

"""#### Creando nuestras propias funciones universales

Para crear una función universal propia, primero necesitamos definir una función tal cual aprendimos. A continuación, hay que añadirla a `numpy` con el método `.frompyfunc()`, que tomará por parámetros la función `function`, el número de inputs (arrays), `inputs` y el número de arrays que devuelve, `outputs`:
"""

def my_sum(x, y):
  return x + y

my_sum = np.frompyfunc(my_sum, 2, 1)
# function = my_sum
# inputs = 2, pues my_sum toma dos arrays
# outputs = 1, pues my_sum devuelve un array, el array suma

a = np.array([1, 0, 7])
b = np.array([-1, 2, 5])
print(my_sum(a, b))

my_sum(np.array([[1,2], [3,4]]), np.array([[1,0], [-1,0]]))

print(type(my_sum))

"""#### Aritmética"""

a = np.array([12, 0, 7])
b = np.array([8, 2, 5])

"""El método `.add()` suma arrays elemento a elemento"""

print(np.add(a, b))

"""El método `.subtract()` resta arrays elemento a elemento

"""

print(np.subtract(a, b))

"""El método `.multiply()` multiplica arrays elemento a elemento"""

print(np.multiply(a, b))

"""El método `.divide()` divide arrays elemento a elemento"""

print(np.divide(a, b))

"""El método `.power()` calcula la potencia del primer array elevado al segundo elemento a elemento"""

print(np.power(a, b))

"""Tanto el método `.mod()` como el método `.remainder()` calculan el resto de la división entera del primer array entre el segundo, elemento a elemento"""

print(np.mod(a, b))
print(np.remainder(a, b))

"""El método `.divmod()` devuelve una tupla con 2 arrays, el primero contiene los cocientes y el segundo los restos de las divisiones enteras elemento a elemento"""

print(np.divmod(a, b))

"""El método `.absolute()` devuelve el valor absoluto de cada elemento de un array"""

print(np.absolute(np.array([-1, 0, -2, 1, 2])))

"""#### Redondeando decimales

En `numpy` tenemos 5 formas de redondear los decimales de un número

* `.trunc()` para truncar
* `.fix()` también para truncar
* `.round()` para redondear
* `.floor()` para redondear a la baja
* `.ceil()` para redondear a la alza
"""

a = np.array([-5.1777, 5.7778, 5.5234])

print("Si truncamos con .trunc(), obtendremos {}".format(np.trunc(a)))
print("Si truncamos con .fix(), obtendremos {}".format(np.fix(a)))

print("Si rendondeamos con .around(), obtendremos {}".format(np.around(a)))

"""**Observación.** Como segundo parámetro, podemos indicar a cuántas cifras decimales queremos redondear"""

print("Si rendondeamos con .round() a 3 cifras decimales, obtendremos {}".
      format(np.round(a, 3)))

print("Si rendondeamos a la baja con .floor(), obtendremos {}".format(np.floor(a)))

print("Si rendondeamos con a la alza .ceil(), obtendremos {}".format(np.ceil(a)))

"""#### Sumas y Diferencias

Ya concoemos el método `.add()` que dados dos arrays los suma elemento a elemento
"""

x = np.array([2, 3, 7])
y = np.array([-1, 5, 0])

print(np.add(x, y))

"""El método `.sum()` nos calcula la suma de los elementos de un array"""

print("La suma de los elementos de x es", np.sum(x))
print("La suma de los elementos de y es", np.sum(y))

"""**Observación.** Cuando por parámetro pasamos un array multidimensional, volvemos a tener disponible el ya más que conocido parámetro `axis`, para seleccionar sobre qué eje queremos realizar la suma"""

z = np.array([[[1, 2], [3, 4], [5, 6], [7, 8]],
              [[2, 4], [3, 6], [4, 8], [5, 10]],
              [[1, 3], [2, 4], [5, 7], [6, 8]]])

for i in range(z.ndim):
  print("\nLa suma de los elementos de z sobre el axis {}  es\n{}".format(i, np.sum(z, axis = i)))

print("\nLa suma de todos los elementos de z es", np.sum(z))

"""Para calcular la suma acumulada de los elementos de un array, disponemos del método `.cumsum()`"""

print("La suma acumulada de los elementos de x es", np.cumsum(x))
print("La suma acumulada de los elementos de y es", np.cumsum(y))

"""**Observación.** Cuando por parámetro pasamos un array multidimensional, volvemos a tener disponible el ya más que conocido parámetro `axis`, para seleccionar sobre qué eje queremos realizar la suma acumulada"""

z = np.array([[[1, 2], [3, 4], [5, 6], [7, 8]],
              [[2, 4], [3, 6], [4, 8], [5, 10]],
              [[1, 3], [2, 4], [5, 7], [6, 8]]])

for i in range(z.ndim):
  print("\nLa suma acumulada de los elementos de z sobre el axis {}  es\n{}".format(i, np.cumsum(z, axis = i)))

print("\nLa suma acumulada de todos los elementos de z es", np.cumsum(z))

"""Para calcular las diferencias entre los elementos de un array, disponemos del método `.diff()`"""

print("La diferencia de elementos sucesivos de x es", np.diff(x))
print("La diferencia de elementos sucesivos de y es", np.diff(y))

"""**Observación.** Cuando por parámetro pasamos un array multidimensional, volvemos a tener disponible el ya más que conocido parámetro `axis`, para seleccionar sobre qué eje queremos realizar la diferencia"""

z = np.array([[[1, 2], [3, 4], [5, 6], [7, 8]],
              [[2, 4], [3, 6], [4, 8], [5, 10]],
              [[1, 3], [2, 4], [5, 7], [6, 8]]])

for i in range(z.ndim):
  print("\nLa diferencia de los elementos sucesivos de z sobre el axis {}  es\n{}".format(i, np.diff(z, axis = i)))

"""El parámetro `n` nos permite elegir cuántas veces queremos calcular la diferencia entre los elementos sucesivos de un array:"""

print("x =", x)
print("Realizando la diferencia entre sus elementos sucesivos obtenemos", np.diff(x))
print("Realizando 2 veces la diferencia entre sus elementos sucesivos obtenemos", np.diff(x, n = 2))

print("y =", y)
print("Realizando la diferencia entre sus elementos sucesivos obtenemos", np.diff(y))
print("Realizando 2 veces la diferencia entre sus elementos sucesivos obtenemos", np.diff(y, n = 2))

"""#### Productos

El método `.prod()` calcula el producto de los elementos de un array
"""

a = np.array([2, 4, 6, 8])
np.prod(a)

"""**Observación.** Cuando por parámetro pasamos un array multidimensional, volvemos a tener disponible el parámetro `axis`, para seleccionar sobre qué eje queremos realizar el producto de los elementos"""

b = np.array([[[1, 2], [3, 4], [5, 6], [7, 8]],
              [[2, -4], [3, -6], [4, -8], [5, -10]],
              [[-1, 3], [-2, 4], [-5, 7], [-6, 8]]])

for i in range(b.ndim):
  print("\nEl producto de los elementos de b sobre el axis {}  es\n{}".format(i, np.prod(b, axis = i)))

print("\nEl producto de todos los elementos de b es", np.prod(b))

"""Con el método `.cumprod()` podemos calcular el producto acumulado de un array"""

a = np.array([2, 4, 6, 8])
np.cumprod(a)

"""**Observación.** Cuando por parámetro pasamos un array multidimensional, volvemos a tener disponible el parámetro `axis`, para seleccionar sobre qué eje queremos realizar el producto de los elementos"""

b = np.array([[[1, 2], [3, 4], [5, 6], [7, 8]],
              [[2, -4], [3, -6], [4, -8], [5, -10]],
              [[-1, 3], [-2, 4], [-5, 7], [-6, 8]]])

for i in range(b.ndim):
  print("\nEl producto acumulado de los elementos de b sobre el axis {}  es\n{}".format(i, np.cumprod(b, axis = i)))

print("\nEl producto acumulado de todos los elementos de b es", np.cumprod(b))

"""#### Logaritmos

Podemos calcular el logaritmo neperiano de todos los elementos de un array con el método `.log()`
"""

a = np.array([5, 12, 34, 7, 55])
print(np.log(a))

"""`numpy` no ofrece ningún método que calcule logartimos en cualquier otra base que no sea `e`. Por eso, la creamos nosotros a partir del método `math.log()`"""

from math import log

nplog = np.frompyfunc(log, 2, 1)
print(nplog(np.array([100, 1000, 50, 500]), 10))

"""#### MCM y MCD

Podemos calcular el Mínimo Común Múltiplo de los elementos de un array con el método `.lcm.reduce()`
"""

a = np.array([2, 3, 5, 12])
np.lcm.reduce(a)

"""Podemos calcular el Máximo Común Divisor de los elementos de un array con el método `.gcd.reduce()`"""

b = np.array([15, 12, 27])
np.gcd.reduce(b)

"""#### Trigonometría

En `numpy` el número $\pi$ se obtiene con `np.pi`.

En `numpy` disponemos de los métodos:

* `.sin()`
* `.cos()`
* `.tan()`

para calcular el seno, coseno y tangente de los elementos de un array (los valores se consideran en radianes)

* `.deg2rad()`
* `.rad2deg()`

para calcular conversión de ángulos a radianes y de radianes a ángulos respectivamente

* `.arcsin()`
* `.arccos()`
* `.arctan()`

para calcular el arcoseno, arcocoseno y arcotangente y hallar ángulos (el resultado es devuelto en radianes)

#### Funciones hiperbólicas

En `numpy` disponemos de los métodos:

* `.sinh()`
* `.cosh()`
* `.tanh()`

para calcular el seno, coseno y tangente hiperbólicos de los elementos de un array (los valores se consideran en radianes)

* `.arcsinh()`
* `.arccosh()`
* `.arctanh()`

para calcular el arcoseno, arcocoseno y arcotangente hiperbólicos y hallar ángulos (el resultado es devuelto en radianes)

#### Conjuntos en `numpy`

Para crear un conjunto a partir de un array, usamos el método `.unique()`:
"""

a = np.array([1, 2, -1, 1, 5, 6, 2, 4, -1, 2])
set_a = np.unique(a)
print(set_a)

"""Para hallar la unión entre dos arrays 1D, usamos el método `.union1d()`"""

x = np.array([1, 2, 3, 4])
y = np.array([-2, -1, 0, 1])
print(np.union1d(x, y))

"""Para hallar la intersección entre dos arrays 1D, usamos el método `.intersect1d()`"""

print(np.intersect1d(x, y))

"""Para hallar la diferencia entre dos arrays 1D, disponemos del método `.setdiff1d()`"""

print(np.setdiff1d(x, y))
print(np.setdiff1d(y, x))

"""Para hallar la diferencia simétrica entre dos arrays 1D, usamos el método `.setxor1d()`"""

print(np.setxor1d(x, y))