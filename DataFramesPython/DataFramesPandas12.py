# -*- coding: utf-8 -*-
"""Tema12.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Km-BvM9hs1jKHzeKw5e8PCvjqQ0QqImO

# Dataframes con el módulo `pandas`

## Introducción

**Dataframe.** Es una estructura bidimensional mutable de datos con los ejes etiquetados donde

- cada fila representa una observación diferente
- cada columna representa una variable diferente

En `Python`, para definir un dataframe, en primer lugar necesitamos importar el módulo `pandas`.
"""

import pandas as pd

"""A continuación, si queremos un dataframe de 5 filas y 2 columnas, podemos hacerlo a partir de un diccionario, una lista de listas, una lista de diccionarios, etc.

---

#### Ejemplo 1

Vamos a crear un dataframe de 5 filas y 2 columnas a partir de un diccionario.

Para ello, primero creamos un diccionario donde las claves serán los nombres de las columnas y los valores serán listas, con tantos elementos como número de filas queramos.

Finalmente, convertimos ese diccionario a dataframe con la función `DataFrame()` de `pandas`:
"""

data = {"x": [1, 2, 3, 4, 5], "y": [2, 4, 6, 8, 10]}
df1 = pd.DataFrame(data = data)
print(df1)

"""Como habíamos dicho, hemos creado un dataframe de 5 filas y dos columnas, llamadas `x` e `y` respectivamente.

**Observación.** Como resultado del `print()`, no solamente hemos obtenido las 5 filas y 2 columnas, sino que hay una columna adicional de 5 números ordenados verticalmete del 0 al 4. Se trata simplemente del nombre de cada fila, que por defecto es el índice de cada fila. El 0 indica la primera fila; el 1, la segunda; y así, sucesivamente.

---

#### Ejemplo 2

Vamos a crear el mismo dataframe de 5 filas y 2 columnas, pero esta vez a partir de una lista de listas.

En este caso, podemos hacerlo directamente con la función `DataFrame()` de `pandas`, usando los parámetros `data` y `columns`
"""

df2 = pd.DataFrame(data = [[1, 2], [2, 4], [3, 6], [4, 8], [5, 10]],
                   columns = ["x", "y"])
print(df2)

"""Al parámetro `data` le hemos proporcionado una lista de 5 listas, donde cada una de las sublistas tiene 2 elementos: el perteneciente a la primera columna en la posición 0, y el perteneciente a la segunda columna en la posición 1.

Al parámetro `columns` le hemos proporcionado el nombre de las 2 columnas.

---

#### Ejemplo 3

Vamos a crear el mismo dataframe de 5 filas y 2 columnas, con la diferencia de que vamos a modificar el nombre de las filas.

Lo haremos a partir del diccionario `data` y utilizaremos el parámetro `index` de la función `DataFrame()` de `pandas`
"""

df3 = pd.DataFrame(data = data, index = ["obs1", "obs2", "obs3", "obs4", "obs5"])
print(df3)

"""En este caso, al parámetro `index` le hemos pasado una lista con 5 strings.

**¡Cuidado!.** Al construir un dataframe a partir de un diccionario (o cualquier objeto de `Python` que contenga algún diccionario), los nombres de las columnas son las claves del diccionario. Si quisiésemos cambiarlos con el parámetro `columns` directamente, nos pasaría lo siguiente:
"""

d = {"a": [1, 2, 3],
     "b": [4, 5, 6],
     "b1": [7, 8, 9]}

df = pd.DataFrame(d, columns = ["a", "b", "c"])
print(df)

"""**Observación.** Si queremos crear un dataframe a partir de un diccionario, pero queremos menos columnas que total de claves tiene el diccionario, no hay problema, siempre y cuando los nombres de las columnas indicados coincidan con las claves del diccionario"""

# Construimos un dataframe solo con las columnas a y b del diccionario d
df = pd.DataFrame(d, columns = ["a", "b"])
print(df)

"""---

#### Ejemplo 4

Vamos a crear el mismo dataframe de 5 filas y 2 columnas, esta vez a partir de una lista de diccionarios.
"""

data = [{"x": 1, "y": 2},
        {"x": 2, "y": 4},
        {"x": 3, "y": 6},
        {"x": 4, "y": 8},
        {"x": 5, "y": 10}]
df4 = pd.DataFrame(data = data)
print(df4)

"""---

#### Ejemplo 5

Incluso podemos crear un dataframe haciendo uso de la función `zip()`.

Para ello, a partir de dos listas, creamos una lista de tuplas, que es la que proporcionamos al parámetro `data` de la función `DataFrame()` para construir el dataframe.
"""

x = [1, 2, 3, 4, 5]
y = [2, 4, 6, 8, 10]

data = list(zip(x, y))
print(data)

df5 = pd.DataFrame(data, columns = ["x", "y"])
print(df5)

"""---

### Creando dataframes con `.from_dict()`

Para construir dataframes a partir de un diccionario, existe el método `.from_dict()`


"""

d = {"a": [1, 2, 3],
     "b": [4, 5, 6],
     "b1": [7, 8, 9]}

df = pd.DataFrame.from_dict(d)
print(df)

"""Lo interesante de este método es que podemos crear un dataframe a partir de un diccionario donde cada clave represente una fila (observación) diferente, gracias al parámetro `orient`"""

d = {"fila1": [1, 4, 7],
     "fila2": [2, 5, 8],
     "fila3": [3, 6, 9]}

df = pd.DataFrame.from_dict(d, orient = "index", columns = ["A", "B", "C"])
print(df)

"""**¡Cuidado!** Para poder usar el parámetro `columns` del método `.from_dict()`, necesitamos que el parámetro `orient` valga `"index"`.

**Observación.** Si no indicásemos el parámetro `orient`, por defecto vale `"columns"`, con lo cual el diccionario suministrado a `data` sería interpretado del siguiente modo: cada clave representaría una columna diferente, tal cual ocurría cuando no usábamos el método `.from_dict()`. Si por el contrario indicamos que `orient = "index"`, lo que estamos haciendo es decirle a `Python` que cada clave del diccionario representa una fila (observación) diferente.

### Dimensiones del dataframe

Con el método `.shape` podemos calcular las dimensiones (número de filas y columnas) del dataframe.
"""

df.shape

"""Como resultado obtenemos una tupla donde el primer elemento es el número de filas, que en nuestro caso es 5, mientras que el segundo elemento es el número de columnas, que en nuestro ejemplo era 2."""

nrows = df.shape[0]
ncols = df.shape[1]
print("El número de filas de df es", nrows)
print("El número de columnas de df es", ncols)

"""Con el método `.size` calculamos el número total de valores que tienes el dataframe (número de filas por número de columnas)"""

df.size

df.shape[0] * df.shape[1] == df.size

"""Finalmente, con el método `.ndim` calculamos el número de dimensiones que tiene el dataframe. Éste siempre valdrá 2, pues consta de filas y columnas."""

df.ndim

"""## Subdataframes

**Subdataframe.** Dado un dataframe, un subdataframe no es más que la selección de unas filas y columnas en particular.

### Columnas

Dado un dataframe, podemos seleccionar una columna en particular de diversas formas:

- Indicando el nombre de la columna entre claudators, `[]`
- Con el método `.columns[]`
- Con el método `.loc[]` (por nombre o etiqueta)
- Con el método `.iloc[]` (por posición)
"""

fdata = {"Name": ["Alicia", "Bill", "Carlos", "Diana"],
        "Age": [22, 28, 19, 34],
        "Pet": [True, False, False, True],
        "Height": [157, 190, 175, 164],
        "Birthday": ["Mayo", "Junio", "Agosto", "Diciembre"]}
df = pd.DataFrame(data = fdata, index = ["obs1", "obs2", "obs3", "obs4"])

df

# Seleccionamos la columna Birthday por nombre
print(df["Birthday"])

# Seleccionamos la columna Birthday con el método .columns[]
print(df[df.columns[4]])

# Seleccionamos la columna Birthday con el método .loc[]
print(df.loc[:, "Birthday"])

"""**Observación.** Al método `.loc[]` le hemos indicado que tome todas las filas con `:` en la primera posición y la columna `"Birthday"` directamente indicando su nommbre en la segunda posición."""

# Seleccionamos la columna Birthday con el método .iloc[]
print(df.iloc[:, 4])

"""**Observación.** Al método `.iloc[]` le hemos indicado que tome todas las filas con `:` en la primera posición y la columna `"Birthday"` indicando el índice que ocupa como columna.

Si quisiésemos seleccionar más de una columna, podríamos hacerlo con todas las opciones enumeradas anteriormente, con ligeras modificaciones en algunos casos:
"""

# Seleccionamos las columnas Name y Age por nombre
print(df[["Name", "Age"]])

# Seleccionamos las columnas Name y Age con el método .columns[]
print(df[df.columns[[0, 1]]])

"""**Observación.** Además, como estas dos columnas están seguidas en nuestro dataframe, podríamos también usar la sintaxis siguiente no solo en esta opción, sino también en el resto de opciones que hemos visto."""

print(df[df.columns[0:2]])

# Seleccionamos las columnas Name y Age con el método .loc[]
print(df.loc[:, ["Name", "Age"]])

print(df.loc[:, "Name":"Age"])

"""**¡Cuidado!** Como podemos ver, al usar `:` con strings, el indicado a la derecha sí que es incluido."""

# Seleccionamos las columnas Name y Age con el método .iloc[]
print(df.iloc[:, [0, 1]])

print(df.iloc[:, 0:2])

"""### Filas

Dado un dataframe, podemos seleccionar una fila en particular de diversas formas:

- Con el método `.loc[]` (por nombre o etiqueta)
- Con el método `.iloc[]` (por posición)

"""

# Seleccionamos la primera observación (obs1) con el método .loc[]
print(df.loc["obs1"])

type(df.loc["obs1"])

# Seleccionamos la última observación con el método .iloc[]
print(df.iloc[-1])

"""Si quisiésemos seleccionar más de una fila, podríamos hacerlo con todas las opciones enumeradas anteriormente, con ligeras modificaciones en algunos casos:"""

# Seleccionamos la segunda y tercera observación con el método .loc[]
print(df.loc[["obs2","obs3"]])

"""**Observación.** Además, como estas dos filas están seguidas en nuestro dataframe, podríamos también usar la sintaxis siguiente no solo en esta opción, sino también en el resto de opciones que hemos visto."""

print(df.loc["obs2":"obs3"])

# Seleccionamos la segunda y tercera observación con el método .iloc[]
print(df.iloc[[1, 2]])

print(df.iloc[1:3])

"""### Filas y columnas

Para seleccionar un elemento en concreto, hay que indicar la fila y la columna y lo podemos hacer de dos formas:

- Con el método `.loc[]` (por nombre o etiqueta)
- Con el método `.iloc[]` (por índice)
"""

# Seleccionamos la edad de la segunda observación con el método .loc[]
print(df.loc["obs2", "Age"])

# Seleccionamos la edad de la segunda observación con el método .iloc[]
print(df.iloc[1, 1])

"""Si queremos seleccionar un subconjunto de filas y columnas, podemos utilizar los dos métodos anteriores"""

# Seleccionamos la segunda y tercera fila y las columnas nombre y cumpleaños
# Con el método .loc[]
print(df.loc["obs2":"obs3", ["Name", "Birthday"]])

# Con el método .iloc[]
print(df.iloc[1:3, [0, 4]])

"""## Métodos de dataframes

El método `.head()` sirve para visualizar las primeras filas del dataframe. Por defecto, se nos mostrarán las 5 primeras


"""

import pandas as pd

d = {"fruit": ["sandía", "melón", "manzana", "cerezas", "plátano", "pera", "melocotón", "fresas"],
     "count": [1, 1, 6, 10, 3, 6, 4, 10]}

df = pd.DataFrame(d)

df.head()

"""Si queremos que se nos muestre un número determinado de filas, tenemos que indicarlo por parámetro:"""

df.head(3)

df.head(6)

"""El método `.tail()` sirve para visualizar las últimas filas del dataframe. Por defecto, se nos mostrarán las 5 últimas"""

df.tail()

"""Si queremos que se nos muestre un número determinado de filas, tenemos que indicarlo por parámetro:"""

df.tail(3)

df.tail(6)

"""El método `.copy()` nos sirve para realizar una copia de un dataframe.

Si simplemente realizamos
"""

fruits = df

"""El dataframe llamado `fruits` es solo una referencia del dataframe original `df` pues si realizamos algún cambio en `fruits`, se realiza también en `df`"""

fruits.iloc[6, 0] = "naranja"
fruits

df

"""En cambio, si `fruits` es definido como"""

fruits = df.copy()

"""entonces ahora sí es una copia independiente del dataframe original y por muchos cambios que hagamos sobre dicha copia, el original se mantiene intacto"""

fruits.iloc[6, 0] = "nectarina"
fruits

df

"""El método `.rename()` se puede utilizar tanto para cambiar las etiquetas de las filas como los nombres de las columnas.

**¡Cuidado!** Para que los cambios se guarden en el dataframe original, necesitamos indicar `inplace = True`, de lo contrario, lo único que estamos haciendo es duplicar el dataframe, cambiando el nombre de las filas o columnas
"""

df.rename(columns = {"fruit": "fruta",
                     "count": "cantidad"})
df

# Cambiamos el nombre de las columnas al dataframe original
df.rename(columns = {"fruit": "fruta",
                     "count": "cantidad"},
          inplace = True)
df

df.rename(index = {0: "obs1",
                   1: "obs2",
                   7: "obs8"})
df

# Cambiamos el nombre de las filas al dataframe original
df.rename(index = {0: "obs1",
                   1: "obs2",
                   7: "obs8"},
          inplace = True)
df

"""Con el método `.columns` también podemos cambiar el nombre de las columnas:"""

df.columns

df.columns = ["FRUTA", "CANTIDAD"]
df

"""El método `.insert()` inserta una nueva columna a un dataframe existente"""

df.insert(loc = 2, column = "PRECIO", value = [2.50, 2.00, 0.35, 0.10, 0.35, 0.20, 0.15, 0.05])
df

"""Al parámetro `loc` le indicamos el índice que ocupará la nueva columna; al parámetro `column` le pasamos el nombre de la nueva columna; y al parámetro `value`, los valores para cada una de las filas.

**Observación.** Si al parámetro `loc` le pasamos un índice ya ocupado por otra columna, se desplazan la columna existente y las de índices superiores un índice a la derecha.

**Observación.** Si al parámetro `value` solo le pasamos un valor, éste será el mismo para todas las filas

"""

df.insert(1, "COLOR", "rojo")
df

"""El método `.drop()` nos permite borrar las filas o columnas que indiquemos

**¡Cuidado!** De nuevo, si queremos aplicar directamente los cambios al dataframe original, necesitamos indicar `inplace = True`
"""

# Eliminamos filas (axis = 0) por etiqueta
df_dropped = df.drop(labels = ["obs1", 4], axis = 0)
df_dropped

# Eliminamos columnas (axis = 1) por etiqueta
df_dropped = df.drop(labels = ["COLOR", "PRECIO"], axis = 1)
df_dropped

"""El método `.pop()` elimina la columna que indiquemos por parámetro"""

column_popped = df.pop("COLOR")
df

column_popped

# Volvemos a añadir la columna recientemente eliminada al final del dataframe con una sintaxis que no habíamos visto todavía
df["COLOR"] = column_popped
df

"""El método `.rank()` devuelve un ranking.

Si por ejemplo queremos un ranking por fruta, el método `.rank()` nos devolverá una columna de posiciones correspondientes a la posición que ocupa cada fruta si estas son ordenadas alfabéticamente

**Observación.** El ranking empieza siempre en 1.
"""

df["RANKING_FRUTA"] = df["FRUTA"].rank()
df

"""Con el parámetro `ascending`, que por defecto vale `True`, podemos indicar si queremos que el ranking sea en orden ascendente o descendente."""

df["RANKING_PRECIO"] = df["PRECIO"].rank(ascending = False)
df

"""El método `.nunique()` devuelve el conteo de cuántos valores únicos hay en cada columna"""

df.nunique()

"""Dada una columna de un dataframe, el método `.unique()` devuelve un array con los valores únicos de dicha columna"""

print(df["COLOR"].unique())

print(df["PRECIO"].unique())

"""El método `.duplicated()` nos ayuda a analizar los valores duplicados. El parámetro `keep` sirve para controlar como proceder con los valores duplicados:

  * `first`: considera la primera aparición del valor repetido como único y el resto como duplicados
  * `last`: considera la última aparición del valor repetido como único y el resto como duplicados
  * `False`: considera todos los repetidos iguales como duplicados
"""

bool_duplicated = df["CANTIDAD"].duplicated(keep = False)
df[bool_duplicated]

"""El método `.drop_duplicates()` elimina los duplicados del dataframe. De nuevo, volvemos a tener el parámetro `keep` y el parámetro `subset` sirve para indicar las columnas a las que queremos aplicar el método:

**Observación.** Para que los cambios sean llevados a cabo en el dataframe original, habrá que indicar `inplace = True`
"""

df_without_duplicates = df.drop_duplicates(subset = "CANTIDAD",
                                           keep = "first")
df_without_duplicates

"""El método `.nsmallest()` nos devuelve las $n$ filas con menor valor de la columna que indiquemos por parámetro"""

# Queremos las 3 observaciones con menor precio
df.nsmallest(3, "PRECIO")

"""El método `.largest()` nos devuelve las $n$ filas con mayor valor de la columna que indiquemos por parámetro"""

# Queremos las 5 observaciones con mayor cantidad
df.nlargest(5, "CANTIDAD")

"""El método `.dtypes` nos indica de qué tipo es cada columna del dataframe"""

df.dtypes

"""## Bucles y dataframes

Para iterar sobre las filas de un dataframe, podemos utilizar los métodos:

- `.iterrows()`
- `.itertuples()`
"""

d = {"name": ["Juan Gabriel", "María", "Ricardo"],
     "surname": ["Gomila", "Santos", "Alberich"],
     "gender": ["m", "f", "m"]}

df = pd.DataFrame(d)
df

"""Usamos `.iterrows()` para obtener el índice de cada fila junto al contenido de cada una:"""

for i, j in df.iterrows():
  print("Índice de la fila: {},\n\nContenido de la fila:\n{}".format(i, j), end = "\n\n\n")

"""Usamos `.itertuples()` para obtener una tupla con toda la información de cada fila:"""

for i in df.itertuples():
  print("Contenido de la fila:\n{}".format(i), end = "\n\n")

"""Para iterar sobre las columnas de un dataframe,

- creamos una lista de las columnas del dataframe y luego iterarmos sobre esa lista para obtener la información de esas columnas
- usamos el métood `.iteritems()`

Creamos la lista de columnas e iteramos sobre esta:
"""

columns = list(df)
print(columns)

for c in columns:
  print("Columna {}:\n{}".format(c, df[c]), end = "\n\n")

"""Usamos `.iteritems()` para obtener el nombre de cada columna junto al contenido de cada una:"""

for i, j in df.iteritems():
  print("Nombre de la columna: {},\n\nContenido de la columna:\n{}".format(i, j), end = "\n\n\n")

"""## Dataframes a partir de archivos CSV

Podemos guardar la información de un archivo csv en un dataframe usando la función `read_csv()`.

El archivo puede

- estar guardado en nuestro directorio de trabajo
- proceder de una url

### Desde directorio de trabajo (con Google Drive)

Vamos a cargar el archivo llamado `characters-simpsons.csv` que tenemos guardado en la carpeta datasets de Google Drive.

Para ello, lo primero que tenemos que hacer es conectar este notebook de Colab con Google Drive.

A continuación, navegamos por nuestro Google Drive hasta encontrar el archivo csv en cuestión. De sus opciones, seleccionamos copiar ruta. Esa ruta será la que pasemos por parámetro a la función `read_csv()`
"""

from google.colab import drive
drive.mount('/content/drive')

simpsons_df = pd.read_csv("/content/drive/MyDrive/python-basico/datasets/characters-simpsons.csv")
simpsons_df.head()

simpsons_df.tail()

"""### Desde url

Vamos a cargar el archivo que contiene la frecuencia de aparición de las letras del alfabeto inglés. Este archivo se llama letter_frequency.csv procede de la siguiente [url](https://people.sc.fsu.edu/~jburkardt/data/csv/letter_frequency.csv)
"""

letters_freq_df = pd.read_csv("https://people.sc.fsu.edu/~jburkardt/data/csv/letter_frequency.csv")
letters_freq_df.columns = ["Letra", "Frecuencia", "Porcentaje"]
letters_freq_df

"""## Dataframes a partir de archivos JSON

Podemos guardar la información de un archivo json en un dataframe usando el método `.read_json()`.

El archivo puede

- estar guardado en nuestro directorio de trabajo
- proceder de una url

### Desde directorio de trabajo (con Google Drive)

Vamos a cargar el archivo llamado `json_index_example.json` que tenemos guardado en la carpeta datasets de Google Drive.

Para ello, lo primero que tenemos que hacer es conectar este notebook de Colab con Google Drive.

A continuación, navegamos por nuestro Google Drive hasta encontrar el archivo json en cuestión. De sus opciones, seleccionamos copiar ruta. Esa ruta será la que pasemos por parámetro al método `.read_json()`
"""

import pandas as pd
quiz_index = pd.read_json("/content/drive/MyDrive/python-basico/datasets/json_index_example.json",
                          orient = "index")
quiz_index.head()

"""#### El parámetro `orient`

En el caso de archivos json, podría darse que no tuvieran la misma configuración que nuestro ejemplo, `json_index_example.json` cuya orientación se corresponde con `index`.

El parámetro `orient` del método `.read_json()` admite otras opciones como `columns` o `values`.

Veamos ambos casos con los ficheros `json_columns_example.json` y `json_values_example.json`, respectivamente.
"""

# Orientación con index
quiz_columns = pd.read_json("/content/drive/MyDrive/python-basico/datasets/json_columns_example.json",
                    orient = "columns")
quiz_columns.head()

# Orientación con values
quiz_values = pd.read_json("/content/drive/MyDrive/python-basico/datasets/json_values_example.json",
                           orient = "values")
quiz_values.head()

"""### Desde url

Vamos a cargar el archivo json que procede de la siguiente [url](https://api.exchangerate-api.com/v4/latest/USD)
"""

from_url = pd.read_json("https://api.exchangerate-api.com/v4/latest/USD")
from_url.head()

"""## Tratamiento de datos faltantes

Los datos faltantes, o en inglés, Missing Data, se dan cuando no hay información para uno o más elementos.

Éste es un problema muy común en la vida real.

En la librería `pandas`, identificamos los missing data con valores `NA` (Not Available) o `NaN` (Not a Number).

Para identificar valores fanltantes en un dataframe de `pandas` , podemos usar los métodos `.isnull()` o `.notnull()`
"""

# Nos devuelve True allí donde hay un dato faltante
simpsons_df.isnull().head()

# Nos devuelve False allí donde hay un dato faltante
simpsons_df.notnull().head()

"""Existen muchas técnicas para tratar con valores faltantes: se sustituyen por la media, por la mediana, se elimina la observación, se interpolan... nosotros no entraremos en detalle en ese aspecto. Simplemente veremos los métodos de `Python` que podemos utilizar para tratar con valores faltantes:

- `.fillna()`
- `.replace()`
- `.interpolate()`
- `.dropna()`

El método `.fillna()` sustituye los valores faltantes por el valor que indiquemos por parámetro
"""

# Necesitamos la librería numpy para crear un dataframe con valores NaN
import numpy as np

data = {"Primer lanzamiento": [100, 86, np.nan, 75, 97],
        "Segundo lanzamiento": [80, np.nan, 63, 81, 88],
        "Tercer lanzamiento": [93, 89, 92, 97, np.nan]
        }

points_df = pd.DataFrame(data, index = ["Jugador 1", "Jugador 2", "Jugador 3", "Jugador 4", "Jugador 5"])
points_df

# Sustituimos todos los NaN por 0 puntos
points_df.fillna(0)

"""Para sustituir valores faltantes con el método `.replace()` lo hacemos del siguiente modo: primero pasamos por parámetro el valor que queremos sustituir y luego, el valor por el cual queremos sustituirlo."""

points_df = pd.DataFrame(data, index = ["Jugador 1", "Jugador 2", "Jugador 3", "Jugador 4", "Jugador 5"])
points_df.replace(np.nan, 0)

"""Si usamos el método `.interpolate()`, sustituiremos los valores `NaN` por valores interpolados. Este método consta de muchos parámetros para elegir el método (que por defecto es `linear`) por el cual llevar a cabo la interpolación."""

points_df = pd.DataFrame(data, index = ["Jugador 1", "Jugador 2", "Jugador 3", "Jugador 4", "Jugador 5"])
points_df.interpolate()

"""El método `.dropna()` elimina las filas que contienen valores faltantes."""

points_df = pd.DataFrame(data, index = ["Jugador 1", "Jugador 2", "Jugador 3", "Jugador 4", "Jugador 5"])
points_df.dropna()

"""## Filtrando dataframes

Dado un dataframe, podemos filtrar sus filas comprobando cuáles satisfacen una condición
"""

# Mostramos las observaciones con porcentaje mayor a 5
letters_freq_df[letters_freq_df["Porcentaje"] > 5]

# Mostramos las observaciones con frecuencia menor o igual a la de la letra S
freq_S = letters_freq_df.loc[18, "Frecuencia"]
letters_freq_df[letters_freq_df["Frecuencia"] <= freq_S]

"""El método `.query()` nos puede ser útil para este cometido, pero funciona únicamente cuando los valores de la columna no contienen espacios en blanco."""

# Mostramos aquellas observaciones cuyo porcentaje es mayor a 5
letters_freq_df.query('Porcentaje > 5')

# Mostramos aquellas observaciones cuyo porcentaje es mayor a 5 y menor o igual a 8
letters_freq_df.query("Porcentaje > 5 and Porcentaje <= 8")

"""## Series de `pandas`

**Serie.** Una Serie de `pandas` es como una columna de un dataframe.

Podemos construir Series de `pandas` a partir de una lista unidimensional
"""

a = [1, 2, 3, 4, 5]
my_series = pd.Series(a)
print(my_series)

"""**Observación.** Si no especificamos nada, por defecto las etiquetas de las entradas de la Serie se corresponden con el índice que ocupan. Recordemos que en `Python` lo índices empiezan por 0.

Estas etiquetas pueden ser usadas para acceder a un valor específico
"""

print(my_series[1])

"""Cuando creamos una Serie, podemos modificar sus etiquetas con el parámetro `index`:"""

my_series = pd.Series(a, index = ["a", "b", "c", "d", "e"])
print(my_series)

"""Ahora, para acceder a una entrada en particular, lo haremos con las nuevas etiquetas:"""

print(my_series["c"])

"""También podemos crear Series a partir de diccionarios. En este caso, las claves se corresponderán con las etiquetas de las series, y los valores del diccionario con los valores que toman las entradas de la Serie."""

videos = {"day1": 5, "day2": 9, "day3": 7, "day4": 6, "day5": 8}
my_series = pd.Series(videos)
print(my_series)

